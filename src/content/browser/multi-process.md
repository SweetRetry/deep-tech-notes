---
title: "æµè§ˆå™¨å¤šè¿›ç¨‹æ¶æ„æ·±åº¦è§£æ"
description: "ä»å•è¿›ç¨‹åˆ°å¤šè¿›ç¨‹ - ç°ä»£æµè§ˆå™¨æ€§èƒ½ä¸å®‰å…¨çš„åŒé‡ä¿éšœ"
pubDate: 2024-01-15
---

# æµè§ˆå™¨å¤šè¿›ç¨‹æ¶æ„æ·±åº¦è§£æ

> ç°ä»£æµè§ˆå™¨ä¸å†æ˜¯ç®€å•çš„æ–‡æ¡£æŸ¥çœ‹å™¨ï¼Œè€Œæ˜¯å¤æ‚çš„åº”ç”¨è¿è¡Œå¹³å°ã€‚ç†è§£å¤šè¿›ç¨‹æ¶æ„ï¼Œå°±æ˜¯ç†è§£ç°ä»£ Web åº”ç”¨æ€§èƒ½å’Œå®‰å…¨çš„åŸºçŸ³ã€‚

## ğŸ¯ ä¸ºä»€ä¹ˆéœ€è¦å¤šè¿›ç¨‹æ¶æ„ï¼Ÿ

### å•è¿›ç¨‹æ—¶ä»£çš„ç—›ç‚¹åˆ†æ

| ç—›ç‚¹é—®é¢˜ | å…·ä½“è¡¨ç° | ç”¨æˆ·ä½“éªŒ | è§£å†³æ–¹æ¡ˆ |
|---------|---------|---------|---------|
| **ç¨³å®šæ€§å·®** | ä¸€ä¸ªé¡µé¢å´©æºƒ â†’ æ•´ä¸ªæµè§ˆå™¨å…³é—­ | ğŸ˜± å·¥ä½œå…¨éƒ¨ä¸¢å¤± | âœ… è¿›ç¨‹éš”ç¦» |
| **æ€§èƒ½ç“¶é¢ˆ** | å•çº¿ç¨‹å¤„ç†æ‰€æœ‰ä»»åŠ¡ | ğŸŒ é¡µé¢å¡é¡¿ä¸¥é‡ | âš¡ å¹¶è¡Œå¤„ç† |
| **å†…å­˜æ³„æ¼** | æ— æ³•æœ‰æ•ˆå›æ”¶å†…å­˜ | ğŸ’¾ ç³»ç»Ÿé€æ¸å¡æ­» | ğŸ”„ è¿›ç¨‹çº§å›æ”¶ |
| **å®‰å…¨é£é™©** | æ¶æ„ä»£ç å½±å“å…¨å±€ | ğŸ›¡ï¸ æ•°æ®æ³„éœ²é£é™© | ğŸ”’ æ²™ç®±éš”ç¦» |

### æ¶æ„æ¼”è¿›å¯¹æ¯”

```
ğŸšï¸ å•è¿›ç¨‹æ—¶ä»£ï¼ˆIE6 æ—¶ä»£ï¼‰:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  æµè§ˆå™¨å”¯ä¸€è¿›ç¨‹                      â”‚
â”‚  â”œâ”€â”€ UI ç•Œé¢                        â”‚
â”‚  â”œâ”€â”€ ç½‘é¡µæ¸²æŸ“                       â”‚
â”‚  â”œâ”€â”€ JavaScript å¼•æ“                â”‚
â”‚  â”œâ”€â”€ ç½‘ç»œè¯·æ±‚                       â”‚
â”‚  â””â”€â”€ æ’ä»¶ç³»ç»Ÿ                       â”‚
â”‚                                    â”‚
â”‚  ğŸ’¥ ä¸€å¤„æ•…éšœ = å…¨ç›˜å´©æºƒ            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ğŸ—ï¸ å¤šè¿›ç¨‹æ—¶ä»£ï¼ˆChrome å¼€åˆ›ï¼‰:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ä¸»è¿›ç¨‹        â”‚  â”‚   æ¸²æŸ“è¿›ç¨‹ 1    â”‚
â”‚   â”œâ”€â”€ UIç®¡ç†    â”‚â—„â”€â”¤   â”œâ”€â”€ DOMè§£æ   â”‚
â”‚   â”œâ”€â”€ è¿›ç¨‹è°ƒåº¦  â”‚  â”‚   â”œâ”€â”€ CSSè®¡ç®—   â”‚
â”‚   â””â”€â”€ èµ„æºç®¡ç†  â”‚  â”‚   â””â”€â”€ JSæ‰§è¡Œ    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²                    â–²
         â”‚                    â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ç½‘ç»œè¿›ç¨‹      â”‚  â”‚   GPUè¿›ç¨‹       â”‚
â”‚   â”œâ”€â”€ HTTPè¯·æ±‚  â”‚  â”‚   â”œâ”€â”€ å›¾å½¢æ¸²æŸ“  â”‚
â”‚   â”œâ”€â”€ ç¼“å­˜ç®¡ç†  â”‚  â”‚   â””â”€â”€ ç¡¬ä»¶åŠ é€Ÿ  â”‚
â”‚   â””â”€â”€ å®‰å…¨æ£€æŸ¥  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ—ï¸ Chrome å¤šè¿›ç¨‹æ¶æ„å…¨æ™¯

### æ ¸å¿ƒè¿›ç¨‹ç±»å‹æ¦‚è§ˆ

| è¿›ç¨‹ç±»å‹ | æ•°é‡ | ä¸»è¦èŒè´£ | å´©æºƒå½±å“ | å†…å­˜å¼€é”€ |
|---------|------|---------|---------|----------|
| **ä¸»è¿›ç¨‹ (Browser)** | 1ä¸ª | UIç•Œé¢ã€è¿›ç¨‹ç®¡ç†ã€å­˜å‚¨ | ğŸš¨ æµè§ˆå™¨å…³é—­ | 50-100MB |
| **æ¸²æŸ“è¿›ç¨‹ (Renderer)** | å¤šä¸ª | é¡µé¢æ¸²æŸ“ã€JavaScriptæ‰§è¡Œ | ğŸ”„ å•æ ‡ç­¾é¡µå´©æºƒ | 50-200MB/ä¸ª |
| **ç½‘ç»œè¿›ç¨‹ (Network)** | 1ä¸ª | ç½‘ç»œè¯·æ±‚ã€ç¼“å­˜ç®¡ç† | ğŸ“¡ ç½‘ç»œåŠŸèƒ½ä¸­æ–­ | 20-50MB |
| **GPUè¿›ç¨‹ (GPU)** | 1ä¸ª | å›¾å½¢æ¸²æŸ“ã€ç¡¬ä»¶åŠ é€Ÿ | ğŸ¨ å›¾å½¢åŠ é€Ÿå¤±æ•ˆ | 30-100MB |
| **æ’ä»¶è¿›ç¨‹ (Plugin)** | å¤šä¸ª | Flashã€PDFç­‰æ’ä»¶ | ğŸ”Œ æ’ä»¶åŠŸèƒ½å¤±æ•ˆ | 10-50MB/ä¸ª |

### è¿›ç¨‹é—´é€šä¿¡æœºåˆ¶

```cpp
// ğŸ”„ IPC é€šä¿¡ç¤ºä¾‹
// ä¸»è¿›ç¨‹å‘æ¸²æŸ“è¿›ç¨‹å‘é€æ¶ˆæ¯
class BrowserToRenderer {
public:
    // å¯¼èˆªåˆ°æ–°é¡µé¢
    void NavigateToURL(const std::string& url) {
        IPC::Message msg;
        msg.set_type(MSG_NAVIGATE);
        msg.set_url(url);
        SendToRenderer(msg);
    }
    
    // å¤„ç†æ¸²æŸ“è¿›ç¨‹å›å¤
    void OnRendererMessage(const IPC::Message& msg) {
        switch(msg.type()) {
            case MSG_PAGE_LOADED:
                OnPageLoaded();
                break;
            case MSG_CRASH_REPORT:
                HandleRendererCrash();
                break;
        }
    }
};
```

---

## ğŸ­ ä¸»è¿›ç¨‹ï¼šæŒ‡æŒ¥å®˜çš„ä½¿å‘½

### ä¸»è¿›ç¨‹æ ¸å¿ƒèŒè´£

ä¸»è¿›ç¨‹æ˜¯æ•´ä¸ªæµè§ˆå™¨çš„æ§åˆ¶ä¸­å¿ƒï¼Œè´Ÿè´£ï¼š

#### 1. ğŸ¨ ç”¨æˆ·ç•Œé¢ç®¡ç†
```cpp
// UI ç»„ä»¶ç®¡ç†
class BrowserMainProcess {
private:
    std::unique_ptr<TabStripModel> tab_model_;
    std::unique_ptr<BookmarkManager> bookmark_manager_;
    std::unique_ptr<DownloadManager> download_manager_;
    
public:
    // åˆ›å»ºæ–°æ ‡ç­¾é¡µ
    void CreateNewTab(const std::string& url) {
        auto* new_tab = tab_model_->CreateTab();
        auto* renderer = CreateRendererProcess();
        renderer->LoadURL(url);
    }
    
    // å¤„ç†ç”¨æˆ·äº¤äº’
    void OnUserInput(const InputEvent& event) {
        auto* active_tab = tab_model_->GetActiveTab();
        ForwardEventToRenderer(active_tab, event);
    }
};
```

#### 2. ğŸ­ è¿›ç¨‹ç”Ÿå‘½å‘¨æœŸç®¡ç†
```cpp
class ProcessManager {
public:
    // æ¸²æŸ“è¿›ç¨‹ç®¡ç†ç­–ç•¥
    enum class ProcessStrategy {
        PROCESS_PER_SITE,      // æ¯ä¸ªç«™ç‚¹ä¸€ä¸ªè¿›ç¨‹
        PROCESS_PER_TAB,       // æ¯ä¸ªæ ‡ç­¾é¡µä¸€ä¸ªè¿›ç¨‹
        PROCESS_SHARED         // å…±äº«è¿›ç¨‹
    };
    
    RenderProcess* GetOrCreateRenderer(const GURL& url) {
        if (strategy_ == PROCESS_PER_SITE) {
            std::string site = GetSiteFromURL(url);
            return GetRendererForSite(site);
        }
        return CreateNewRenderer();
    }
    
    // è¿›ç¨‹å¥åº·ç›‘æ§
    void MonitorProcessHealth() {
        for (auto& process : renderer_processes_) {
            if (process->IsUnresponsive()) {
                KillAndRecreateProcess(process.get());
            }
        }
    }
};
```

#### 3. ğŸ’¾ æ•°æ®å­˜å‚¨ç®¡ç†
```cpp
class StorageManager {
public:
    // Cookie ç®¡ç†
    void SetCookie(const std::string& domain, const Cookie& cookie) {
        cookie_store_->SetCookie(domain, cookie);
    }
    
    // æœ¬åœ°å­˜å‚¨
    void WriteToLocalStorage(const std::string& origin, 
                           const std::string& key, 
                           const std::string& value) {
        local_storage_->Set(origin, key, value);
    }
    
    // ç¼“å­˜ç®¡ç†
    void CacheResource(const std::string& url, 
                      const std::vector<uint8_t>& data) {
        disk_cache_->Store(url, data);
    }
};
```

### ä¸»è¿›ç¨‹å†…å­˜ç®¡ç†

```cpp
// å†…å­˜ç›‘æ§å’Œä¼˜åŒ–
class BrowserMemoryManager {
public:
    struct MemoryStats {
        size_t total_memory_mb;
        size_t browser_process_mb;
        size_t renderer_processes_mb;
        size_t gpu_process_mb;
        size_t network_process_mb;
    };
    
    MemoryStats GetCurrentStats() {
        MemoryStats stats;
        stats.browser_process_mb = GetBrowserProcessMemory();
        
        for (auto& renderer : renderer_processes_) {
            stats.renderer_processes_mb += renderer->GetMemoryUsage();
        }
        
        return stats;
    }
    
    // å†…å­˜å‹åŠ›å¤„ç†
    void HandleMemoryPressure() {
        // 1. æ¸…ç†æœªä½¿ç”¨çš„æ¸²æŸ“è¿›ç¨‹
        CleanupUnusedRenderers();
        
        // 2. é€šçŸ¥æ¸²æŸ“è¿›ç¨‹é‡Šæ”¾å†…å­˜
        for (auto& renderer : renderer_processes_) {
            renderer->ReduceMemoryUsage();
        }
        
        // 3. æ¸…ç†ç£ç›˜ç¼“å­˜
        disk_cache_->EvictOldEntries();
    }
};
```

---

## ğŸ¨ æ¸²æŸ“è¿›ç¨‹ï¼šå†…å®¹åˆ›é€ è€…

### æ¸²æŸ“è¿›ç¨‹æ¶æ„è¯¦è§£

æ¯ä¸ªæ¸²æŸ“è¿›ç¨‹éƒ½æ˜¯ä¸€ä¸ªæ²™ç®±ç¯å¢ƒï¼ŒåŒ…å«å®Œæ•´çš„ç½‘é¡µå¤„ç†èƒ½åŠ›ï¼š

```cpp
class RenderProcess {
private:
    std::unique_ptr<BlinkEngine> blink_engine_;     // Blink æ¸²æŸ“å¼•æ“
    std::unique_ptr<V8Engine> v8_engine_;           // JavaScript å¼•æ“
    std::unique_ptr<NetworkClient> network_client_; // ç½‘ç»œå®¢æˆ·ç«¯
    
public:
    // é¡µé¢åŠ è½½æµç¨‹
    void LoadURL(const std::string& url) {
        // 1. è¯·æ±‚ HTML æ–‡æ¡£
        auto html_content = network_client_->FetchHTML(url);
        
        // 2. è§£æ DOM
        auto dom_tree = blink_engine_->ParseHTML(html_content);
        
        // 3. åŠ è½½æ ·å¼è¡¨
        auto css_content = network_client_->FetchCSS(url);
        auto style_tree = blink_engine_->ParseCSS(css_content);
        
        // 4. æ„å»ºæ¸²æŸ“æ ‘
        auto render_tree = blink_engine_->BuildRenderTree(dom_tree, style_tree);
        
        // 5. å¸ƒå±€è®¡ç®—
        blink_engine_->Layout(render_tree);
        
        // 6. ç»˜åˆ¶
        blink_engine_->Paint(render_tree);
    }
    
    // JavaScript æ‰§è¡Œ
    void ExecuteScript(const std::string& script) {
        v8_engine_->Execute(script);
    }
};
```

### æ¸²æŸ“ç®¡é“æ€§èƒ½ä¼˜åŒ–

| æ¸²æŸ“é˜¶æ®µ | ä¼˜åŒ–ç­–ç•¥ | æ€§èƒ½æå‡ | å®ç°æŠ€æœ¯ |
|---------|---------|---------|---------|
| **DOM è§£æ** | å¢é‡è§£æã€é¢„è§£æ | 30-50% | Streaming Parser |
| **æ ·å¼è®¡ç®—** | æ ·å¼ç¼“å­˜ã€é€‰æ‹©å™¨ä¼˜åŒ– | 20-40% | Style Invalidation |
| **å¸ƒå±€è®¡ç®—** | è„çŸ©å½¢ã€å±‚æ¬¡ä¼˜åŒ– | 40-60% | Layout Thrashing é¿å… |
| **åˆæˆ** | GPU åŠ é€Ÿã€å±‚åˆ†ç¦» | 50-80% | Compositor Layers |

```cpp
// æ¸²æŸ“ä¼˜åŒ–ç¤ºä¾‹
class RenderOptimizer {
public:
    // é¿å…å¸ƒå±€æŠ–åŠ¨
    void OptimizeLayoutThrashing() {
        // æ‰¹é‡è¯»å–å¸ƒå±€å±æ€§
        std::vector<LayoutInfo> layout_infos;
        for (auto& element : elements_) {
            layout_infos.push_back(element->GetLayoutInfo());
        }
        
        // æ‰¹é‡å†™å…¥æ ·å¼æ›´æ”¹
        for (size_t i = 0; i < elements_.size(); ++i) {
            elements_[i]->ApplyStyleChanges(layout_infos[i]);
        }
    }
    
    // GPU å±‚æå‡
    void PromoteToCompositorLayer(Element* element) {
        if (ShouldPromoteElement(element)) {
            element->SetStyle("will-change", "transform");
            element->SetStyle("transform", "translateZ(0)");
        }
    }
    
private:
    bool ShouldPromoteElement(Element* element) {
        return element->HasAnimations() || 
               element->HasTransformProperty() ||
               element->IsVideoElement();
    }
};
```

### JavaScript å¼•æ“ä¼˜åŒ–

```cpp
// V8 å¼•æ“æ€§èƒ½ä¼˜åŒ–
class V8Optimizer {
public:
    // JIT ç¼–è¯‘ä¼˜åŒ–
    void OptimizeHotFunctions() {
        for (auto& function : hot_functions_) {
            if (function->CallCount() > kOptimizationThreshold) {
                v8_engine_->OptimizeFunction(function.get());
            }
        }
    }
    
    // å†…å­˜ç®¡ç†
    void ManageHeapMemory() {
        // å¢é‡åƒåœ¾å›æ”¶
        if (ShouldPerformGC()) {
            v8_engine_->PerformIncrementalGC();
        }
        
        // å †å‹ç¼©
        if (HeapFragmentationHigh()) {
            v8_engine_->CompactHeap();
        }
    }
    
    // Worker çº¿ç¨‹ç®¡ç†
    void ManageWorkerThreads() {
        for (auto& worker : web_workers_) {
            if (worker->IsIdle() && worker->IdleTime() > kWorkerTimeoutMs) {
                TerminateWorker(worker.get());
            }
        }
    }
};
```

---

## ğŸŒ ç½‘ç»œè¿›ç¨‹ï¼šæ•°æ®ä¼ è¾“ä¸“å®¶

### ç½‘ç»œè¿›ç¨‹èŒè´£æ¶æ„

```cpp
class NetworkProcess {
private:
    std::unique_ptr<URLLoaderFactory> url_loader_factory_;
    std::unique_ptr<CookieManager> cookie_manager_;
    std::unique_ptr<CacheManager> cache_manager_;
    std::unique_ptr<ProxyResolver> proxy_resolver_;
    
public:
    // ç½‘ç»œè¯·æ±‚å¤„ç†
    void HandleNetworkRequest(const NetworkRequest& request) {
        // 1. æ£€æŸ¥ç¼“å­˜
        if (auto cached_response = cache_manager_->Get(request.url)) {
            SendCachedResponse(*cached_response);
            return;
        }
        
        // 2. ä»£ç†è§£æ
        auto proxy_info = proxy_resolver_->Resolve(request.url);
        
        // 3. DNS è§£æ
        auto ip_address = dns_resolver_->Resolve(request.hostname);
        
        // 4. å»ºç«‹è¿æ¥
        auto socket = socket_pool_->GetSocket(ip_address, request.port);
        
        // 5. å‘é€è¯·æ±‚
        socket->SendRequest(request);
        
        // 6. æ¥æ”¶å“åº”
        auto response = socket->ReceiveResponse();
        
        // 7. ç¼“å­˜å“åº”
        cache_manager_->Store(request.url, response);
        
        // 8. è½¬å‘åˆ°æ¸²æŸ“è¿›ç¨‹
        ForwardToRenderer(response);
    }
};
```

### ç½‘ç»œæ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 1. è¿æ¥ç®¡ç†ä¼˜åŒ–
```cpp
class ConnectionManager {
public:
    // HTTP/2 å¤šè·¯å¤ç”¨
    void EnableHTTP2Multiplexing() {
        for (auto& connection : connections_) {
            if (connection->SupportsHTTP2()) {
                connection->EnableMultiplexing();
                connection->SetMaxConcurrentStreams(256);
            }
        }
    }
    
    // è¿æ¥æ± ä¼˜åŒ–
    void OptimizeConnectionPool() {
        // é¢„è¿æ¥çƒ­é—¨åŸŸå
        for (const auto& domain : popular_domains_) {
            PreconnectToDomain(domain);
        }
        
        // å…³é—­ç©ºé—²è¿æ¥
        CloseIdleConnections(kIdleTimeoutSeconds);
    }
};
```

#### 2. ç¼“å­˜ç­–ç•¥ä¼˜åŒ–
```cpp
class CacheManager {
public:
    enum class CacheStrategy {
        MEMORY_FIRST,    // å†…å­˜ä¼˜å…ˆ
        DISK_PERSISTENT, // ç£ç›˜æŒä¹…åŒ–
        HYBRID_CACHE     // æ··åˆç¼“å­˜
    };
    
    // æ™ºèƒ½ç¼“å­˜å†³ç­–
    void CacheResource(const std::string& url, const Response& response) {
        CacheStrategy strategy = DetermineCacheStrategy(response);
        
        switch (strategy) {
            case MEMORY_FIRST:
                memory_cache_->Store(url, response);
                break;
            case DISK_PERSISTENT:
                disk_cache_->Store(url, response);
                break;
            case HYBRID_CACHE:
                memory_cache_->Store(url, response.headers);
                disk_cache_->Store(url, response.body);
                break;
        }
    }
    
private:
    CacheStrategy DetermineCacheStrategy(const Response& response) {
        if (response.size < kMemoryCacheThreshold) {
            return MEMORY_FIRST;
        }
        if (response.cache_control.max_age > kLongTermCacheThreshold) {
            return DISK_PERSISTENT;
        }
        return HYBRID_CACHE;
    }
};
```

#### 3. è¯·æ±‚ä¼˜åŒ–æŠ€æœ¯

| ä¼˜åŒ–æŠ€æœ¯ | å®ç°åŸç† | æ€§èƒ½æå‡ | é€‚ç”¨åœºæ™¯ |
|---------|---------|---------|---------|
| **DNS é¢„è§£æ** | æå‰è§£æåŸŸå | å‡å°‘ 20-100ms | å·²çŸ¥è·³è½¬é“¾æ¥ |
| **TCP é¢„è¿æ¥** | æå‰å»ºç«‹è¿æ¥ | å‡å°‘ 100-300ms | å…³é”®èµ„æºåŸŸå |
| **HTTP/2 æ¨é€** | æœåŠ¡å™¨ä¸»åŠ¨æ¨é€ | å‡å°‘å¾€è¿”æ—¶é—´ 50% | å…³é”® CSS/JS |
| **èµ„æºé¢„åŠ è½½** | æå‰åŠ è½½èµ„æº | æ”¹å–„ LCP 20-40% | é¦–å±å…³é”®èµ„æº |

```cpp
// é¢„åŠ è½½ç­–ç•¥å®ç°
class ResourcePreloader {
public:
    // DNS é¢„è§£æ
    void PreresolveDNS(const std::vector<std::string>& domains) {
        for (const auto& domain : domains) {
            dns_resolver_->ResolveAsync(domain);
        }
    }
    
    // èµ„æºé¢„åŠ è½½
    void PreloadCriticalResources(const std::vector<std::string>& urls) {
        for (const auto& url : urls) {
            NetworkRequest request;
            request.url = url;
            request.priority = HIGHEST;
            request.cache_mode = FORCE_CACHE;
            
            url_loader_factory_->CreateLoader(request);
        }
    }
    
    // HTTP/2 æ¨é€
    void ConfigureServerPush(const std::string& html_url, 
                           const std::vector<std::string>& push_urls) {
        for (const auto& push_url : push_urls) {
            server_push_manager_->AddPushPromise(html_url, push_url);
        }
    }
};
```

---

## ğŸ® GPUè¿›ç¨‹ï¼šå›¾å½¢åŠ é€Ÿå¼•æ“

### GPUè¿›ç¨‹æ¶æ„è®¾è®¡

```cpp
class GPUProcess {
private:
    std::unique_ptr<CommandBuffer> command_buffer_;
    std::unique_ptr<GLContext> gl_context_;
    std::unique_ptr<VulkanContext> vulkan_context_;
    
public:
    // å›¾å½¢å‘½ä»¤å¤„ç†
    void ProcessGraphicsCommands() {
        while (auto command = command_buffer_->GetNextCommand()) {
            switch (command->type()) {
                case CLEAR_BUFFER:
                    ClearFrameBuffer(command->color());
                    break;
                case DRAW_TRIANGLES:
                    DrawTriangles(command->vertices());
                    break;
                case APPLY_SHADER:
                    ApplyShaderProgram(command->shader());
                    break;
                case PRESENT_FRAME:
                    PresentToScreen();
                    break;
            }
        }
    }
    
    // ç¡¬ä»¶åŠ é€Ÿæ£€æµ‹
    bool SupportsHardwareAcceleration() {
        return gl_context_->IsValid() && 
               HasSufficientVRAM() && 
               SupportsRequiredExtensions();
    }
};
```

### æ¸²æŸ“æ€§èƒ½ä¼˜åŒ–

#### 1. åˆæˆå±‚ä¼˜åŒ–
```cpp
class CompositorOptimizer {
public:
    // æ™ºèƒ½å±‚æå‡
    void OptimizeLayerPromotion() {
        for (auto& element : elements_) {
            if (ShouldPromoteToLayer(element)) {
                PromoteToCompositorLayer(element);
            }
        }
    }
    
private:
    bool ShouldPromoteToLayer(const Element& element) {
        return element.HasTransformAnimation() ||
               element.HasOpacityAnimation() ||
               element.Has3DTransform() ||
               element.IsVideo() ||
               element.IsCanvas();
    }
    
    void PromoteToCompositorLayer(Element& element) {
        element.CreateGraphicsLayer();
        element.SetNeedsCompositedScrolling(true);
        element.SetShouldFlattenTransform(false);
    }
};
```

#### 2. æ¸²æŸ“æµæ°´çº¿ä¼˜åŒ–

| ä¼˜åŒ–é˜¶æ®µ | æŠ€æœ¯æ‰‹æ®µ | æ€§èƒ½æ”¶ç›Š | å®ç°å¤æ‚åº¦ |
|---------|---------|---------|-----------|
| **å‡ ä½•å¤„ç†** | GPU é¡¶ç‚¹ç¼“å†² | 2-5x æå‡ | ğŸŸ¡ ä¸­ç­‰ |
| **å…‰æ …åŒ–** | ç“¦ç‰‡å¼æ¸²æŸ“ | 30-50% æå‡ | ğŸŸ¢ ç®€å• |
| **åˆæˆ** | å¼‚æ­¥åˆæˆ | é¿å…ä¸»çº¿ç¨‹é˜»å¡ | ğŸ”´ å¤æ‚ |
| **æ˜¾ç¤º** | å‚ç›´åŒæ­¥ | æ¶ˆé™¤æ’•è£‚ | ğŸŸ¢ ç®€å• |

```cpp
// GPU æ¸²æŸ“ä¼˜åŒ–
class GPURenderer {
public:
    // æ‰¹é‡æ¸²æŸ“ä¼˜åŒ–
    void BatchRenderOperations() {
        std::vector<RenderCommand> batched_commands;
        
        // åˆå¹¶ç›¸åŒæè´¨çš„ç»˜åˆ¶è°ƒç”¨
        for (auto& command : pending_commands_) {
            if (CanBatchWith(batched_commands.back(), command)) {
                batched_commands.back().Merge(command);
            } else {
                batched_commands.push_back(command);
            }
        }
        
        // æ‰§è¡Œæ‰¹é‡æ¸²æŸ“
        for (const auto& batch : batched_commands) {
            ExecuteRenderBatch(batch);
        }
    }
    
    // çº¹ç†ç®¡ç†ä¼˜åŒ–
    void OptimizeTextureMemory() {
        // çº¹ç†å‹ç¼©
        for (auto& texture : textures_) {
            if (texture->CanCompress()) {
                texture->CompressToFormat(TEXTURE_COMPRESSION_S3TC);
            }
        }
        
        // çº¹ç†æµå¼åŠ è½½
        for (auto& texture : large_textures_) {
            LoadTextureProgressive(texture.get());
        }
    }
};
```

---

## ğŸ”„ è¿›ç¨‹é—´é€šä¿¡ (IPC) æ·±åº¦è§£æ

### IPC é€šä¿¡æœºåˆ¶å¯¹æ¯”

| é€šä¿¡æ–¹å¼ | å»¶è¿Ÿ | ååé‡ | å®‰å…¨æ€§ | ä½¿ç”¨åœºæ™¯ |
|---------|------|-------|-------|---------|
| **å‘½åç®¡é“** | ä½ | é«˜ | ä¸­ç­‰ | æœ¬åœ°è¿›ç¨‹é€šä¿¡ |
| **å…±äº«å†…å­˜** | æä½ | æé«˜ | ä½ | å¤§æ•°æ®ä¼ è¾“ |
| **æ¶ˆæ¯é˜Ÿåˆ—** | ä¸­ç­‰ | ä¸­ç­‰ | é«˜ | å¼‚æ­¥é€šä¿¡ |
| **å¥—æ¥å­—** | é«˜ | ä¸­ç­‰ | é«˜ | è·¨ç½‘ç»œé€šä¿¡ |

### IPC å®ç°ç»†èŠ‚

```cpp
// Mojo IPC ç³»ç»Ÿå®ç°
class MojoIPCChannel {
public:
    // æ¶ˆæ¯å‘é€
    void SendMessage(const IPC::Message& message) {
        // 1. åºåˆ—åŒ–æ¶ˆæ¯
        auto serialized = message_serializer_->Serialize(message);
        
        // 2. åŠ å¯†ï¼ˆå¦‚æœéœ€è¦ï¼‰
        if (security_enabled_) {
            serialized = crypto_->Encrypt(serialized);
        }
        
        // 3. é€šè¿‡ç®¡é“å‘é€
        pipe_->Write(serialized);
    }
    
    // æ¶ˆæ¯æ¥æ”¶
    void ReceiveMessage() {
        pipe_->ReadAsync([this](const std::vector<uint8_t>& data) {
            // è§£å¯†
            auto decrypted = crypto_->Decrypt(data);
            
            // ååºåˆ—åŒ–
            auto message = message_serializer_->Deserialize(decrypted);
            
            // åˆ†å‘å¤„ç†
            message_dispatcher_->Dispatch(message);
        });
    }
    
    // å¤§æ•°æ®ä¼ è¾“ä¼˜åŒ–
    void SendLargeData(const std::vector<uint8_t>& data) {
        if (data.size() > kSharedMemoryThreshold) {
            // ä½¿ç”¨å…±äº«å†…å­˜
            auto shared_region = CreateSharedMemoryRegion(data.size());
            std::memcpy(shared_region->GetMemory(), data.data(), data.size());
            
            IPC::Message message;
            message.set_shared_memory_handle(shared_region->GetHandle());
            SendMessage(message);
        } else {
            // ç›´æ¥å‘é€
            IPC::Message message;
            message.set_data(data);
            SendMessage(message);
        }
    }
};
```

### å®‰å…¨æ²™ç®±æœºåˆ¶

```cpp
class SandboxManager {
public:
    // æ¸²æŸ“è¿›ç¨‹æ²™ç®±é…ç½®
    void ConfigureRendererSandbox(ProcessHandle renderer_process) {
        SandboxPolicy policy;
        
        // æ–‡ä»¶ç³»ç»Ÿè®¿é—®é™åˆ¶
        policy.DisallowFileSystemAccess();
        policy.AllowReadOnlyAccess("/usr/share/fonts/");
        policy.AllowReadOnlyAccess("/usr/share/ca-certificates/");
        
        // ç½‘ç»œè®¿é—®é™åˆ¶  
        policy.DisallowDirectNetworkAccess();
        
        // ç³»ç»Ÿè°ƒç”¨é™åˆ¶
        policy.AllowSyscall(SYS_read);
        policy.AllowSyscall(SYS_write);
        policy.DisallowSyscall(SYS_open);
        policy.DisallowSyscall(SYS_execve);
        
        // åº”ç”¨æ²™ç®±ç­–ç•¥
        ApplySandboxPolicy(renderer_process, policy);
    }
    
    // æƒé™æ£€æŸ¥
    bool CheckPermission(ProcessHandle process, const std::string& resource) {
        auto policy = GetProcessPolicy(process);
        return policy->AllowsAccess(resource);
    }
};
```

---

## ğŸ“Š æ€§èƒ½ç›‘æ§ä¸è°ƒä¼˜

### å…³é”®æ€§èƒ½æŒ‡æ ‡

```cpp
class PerformanceMonitor {
public:
    struct ProcessMetrics {
        // å†…å­˜æŒ‡æ ‡
        size_t private_memory_kb;      // ç§æœ‰å†…å­˜
        size_t shared_memory_kb;       // å…±äº«å†…å­˜
        size_t virtual_memory_kb;      // è™šæ‹Ÿå†…å­˜
        
        // CPU æŒ‡æ ‡
        double cpu_usage_percent;      // CPU ä½¿ç”¨ç‡
        uint64_t context_switches;     // ä¸Šä¸‹æ–‡åˆ‡æ¢æ¬¡æ•°
        
        // IPC æŒ‡æ ‡
        uint64_t messages_sent;        // å‘é€æ¶ˆæ¯æ•°
        uint64_t messages_received;    // æ¥æ”¶æ¶ˆæ¯æ•°
        double average_latency_ms;     // å¹³å‡å»¶è¿Ÿ
        
        // æ¸²æŸ“æŒ‡æ ‡
        uint32_t frames_per_second;    // å¸§ç‡
        double paint_time_ms;          // ç»˜åˆ¶æ—¶é—´
        double layout_time_ms;         // å¸ƒå±€æ—¶é—´
    };
    
    // æ”¶é›†æ€§èƒ½æ•°æ®
    ProcessMetrics CollectMetrics(ProcessHandle process) {
        ProcessMetrics metrics;
        
        // å†…å­˜ç»Ÿè®¡
        auto memory_info = GetProcessMemoryInfo(process);
        metrics.private_memory_kb = memory_info.private_bytes / 1024;
        metrics.shared_memory_kb = memory_info.shared_bytes / 1024;
        
        // CPU ç»Ÿè®¡
        auto cpu_info = GetProcessCPUInfo(process);
        metrics.cpu_usage_percent = cpu_info.usage_percent;
        
        return metrics;
    }
    
    // æ€§èƒ½å‘Šè­¦
    void CheckPerformanceAlerts(const ProcessMetrics& metrics) {
        if (metrics.private_memory_kb > kMemoryWarningThreshold) {
            TriggerMemoryWarning(metrics.private_memory_kb);
        }
        
        if (metrics.cpu_usage_percent > kCPUWarningThreshold) {
            TriggerCPUWarning(metrics.cpu_usage_percent);
        }
        
        if (metrics.frames_per_second < kFPSWarningThreshold) {
            TriggerRenderingWarning(metrics.frames_per_second);
        }
    }
};
```

### æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

#### 1. å†…å­˜ä¼˜åŒ–
```cpp
class MemoryOptimizer {
public:
    // æ¸²æŸ“è¿›ç¨‹å†…å­˜å›æ”¶
    void OptimizeRendererMemory() {
        for (auto& renderer : renderer_processes_) {
            if (renderer->GetMemoryUsage() > kMemoryPressureThreshold) {
                // è§¦å‘ JavaScript åƒåœ¾å›æ”¶
                renderer->TriggerGarbageCollection();
                
                // æ¸…ç† DOM ç¼“å­˜
                renderer->ClearDOMNodeCache();
                
                // å‹ç¼©å›¾ç‰‡ç¼“å­˜
                renderer->CompressImageCache();
            }
        }
    }
    
    // è¿›ç¨‹åˆå¹¶ç­–ç•¥
    void ConsolidateProcesses() {
        auto low_memory_renderers = GetLowMemoryRenderers();
        
        for (auto& renderer : low_memory_renderers) {
            if (CanMergeWithExisting(renderer)) {
                MergeRendererProcess(renderer);
            }
        }
    }
};
```

#### 2. å¯åŠ¨é€Ÿåº¦ä¼˜åŒ–

| ä¼˜åŒ–æŠ€æœ¯ | å®ç°æ–¹å¼ | æ•ˆæœ | å¤æ‚åº¦ |
|---------|---------|------|-------|
| **è¿›ç¨‹é¢„å¯åŠ¨** | é¢„åˆ›å»ºæ¸²æŸ“è¿›ç¨‹æ±  | å‡å°‘ 50-200ms | ğŸŸ¡ ä¸­ç­‰ |
| **ä»£ç åˆ†ç‰‡** | æŒ‰éœ€åŠ è½½æ¨¡å— | å‡å°‘ 30-100ms | ğŸ”´ å¤æ‚ |
| **ç¼“å­˜é¢„çƒ­** | é¢„åŠ è½½çƒ­ç‚¹æ•°æ® | å‡å°‘ 20-80ms | ğŸŸ¢ ç®€å• |
| **å¹¶è¡Œåˆå§‹åŒ–** | å¼‚æ­¥åˆå§‹åŒ–ç»„ä»¶ | å‡å°‘ 40-150ms | ğŸŸ¡ ä¸­ç­‰ |

```cpp
// å¯åŠ¨ä¼˜åŒ–å®ç°
class StartupOptimizer {
public:
    // è¿›ç¨‹æ± é¢„çƒ­
    void WarmupProcessPool() {
        // é¢„åˆ›å»ºæ¸²æŸ“è¿›ç¨‹
        for (int i = 0; i < kPrewarmRendererCount; ++i) {
            auto renderer = CreateRendererProcess();
            renderer->Initialize();
            renderer_pool_.push_back(std::move(renderer));
        }
        
        // é¢„çƒ­ GPU è¿›ç¨‹
        gpu_process_->WarmupGraphicsContext();
        
        // é¢„çƒ­ç½‘ç»œè¿›ç¨‹
        network_process_->WarmupNetworkStack();
    }
    
    // å…³é”®è·¯å¾„ä¼˜åŒ–
    void OptimizeCriticalPath() {
        // å¹¶è¡Œåˆå§‹åŒ–
        std::vector<std::future<void>> init_tasks;
        
        init_tasks.push_back(std::async(std::launch::async, [this]() {
            InitializeUIComponents();
        }));
        
        init_tasks.push_back(std::async(std::launch::async, [this]() {
            InitializeNetworkServices();
        }));
        
        init_tasks.push_back(std::async(std::launch::async, [this]() {
            InitializeStorageServices();
        }));
        
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        for (auto& task : init_tasks) {
            task.wait();
        }
    }
};
```

---

## ğŸ”® æœªæ¥å‘å±•è¶‹åŠ¿

### Site Isolation å®‰å…¨å¢å¼º

```cpp
// ç«™ç‚¹éš”ç¦»å®ç°
class SiteIsolationManager {
public:
    // è·¨ç«™æ–‡æ¡£éš”ç¦»
    bool ShouldIsolateFrame(const GURL& parent_url, const GURL& child_url) {
        // ä¸åŒæºéœ€è¦éš”ç¦»
        if (GetOrigin(parent_url) != GetOrigin(child_url)) {
            return true;
        }
        
        // æ•æ„Ÿç«™ç‚¹å¼ºåˆ¶éš”ç¦»
        if (IsSensitiveSite(child_url)) {
            return true;
        }
        
        return false;
    }
    
    // è·¨è¿›ç¨‹é€šä¿¡é™åˆ¶
    void EnforceIsolationPolicy(ProcessHandle sender, 
                               ProcessHandle receiver, 
                               const IPC::Message& message) {
        if (!CanCommunicate(sender, receiver)) {
            BlockMessage(message);
            LogSecurityViolation(sender, receiver);
        }
    }
};
```

### æœåŠ¡åŒ–æ¶æ„æ¼”è¿›

```cpp
// æœåŠ¡åŒ–ç»„ä»¶è®¾è®¡
class BrowserService {
public:
    virtual ~BrowserService() = default;
    virtual void Initialize() = 0;
    virtual void Shutdown() = 0;
    virtual std::string GetServiceName() const = 0;
};

class StorageService : public BrowserService {
public:
    void Initialize() override {
        InitializeDatabase();
        StartMaintenanceScheduler();
    }
    
    std::string GetServiceName() const override {
        return "storage_service";
    }
    
    // å­˜å‚¨æ¥å£
    void StoreData(const std::string& key, const std::vector<uint8_t>& data);
    std::optional<std::vector<uint8_t>> RetrieveData(const std::string& key);
};

class ServiceManager {
public:
    template<typename ServiceType>
    void RegisterService() {
        auto service = std::make_unique<ServiceType>();
        services_[service->GetServiceName()] = std::move(service);
    }
    
    template<typename ServiceType>
    ServiceType* GetService() {
        auto it = services_.find(ServiceType::kServiceName);
        return static_cast<ServiceType*>(it->second.get());
    }
};
```

---

## ğŸ¯ å®æˆ˜åº”ç”¨ä¸è°ƒè¯•

### å¼€å‘è€…å·¥å…·é›†æˆ

```cpp
class DevToolsIntegration {
public:
    // è¿›ç¨‹ç›‘æ§é¢æ¿
    void ShowProcessMonitor() {
        auto metrics = performance_monitor_->CollectAllMetrics();
        
        DevToolsAPI::SendEvent("performance.processMetrics", {
            {"browser_process", SerializeMetrics(metrics.browser)},
            {"renderer_processes", SerializeMetrics(metrics.renderers)},
            {"network_process", SerializeMetrics(metrics.network)},
            {"gpu_process", SerializeMetrics(metrics.gpu)}
        });
    }
    
    // å†…å­˜æ³„æ¼æ£€æµ‹
    void DetectMemoryLeaks() {
        for (auto& renderer : renderer_processes_) {
            auto heap_snapshot = renderer->TakeHeapSnapshot();
            auto leaks = AnalyzeHeapSnapshot(heap_snapshot);
            
            if (!leaks.empty()) {
                DevToolsAPI::SendWarning("memory.leaksDetected", leaks);
            }
        }
    }
};
```

### æ€§èƒ½è°ƒä¼˜å®æˆ˜

```cpp
// æ€§èƒ½é—®é¢˜è¯Šæ–­å·¥å…·
class PerformanceDiagnostics {
public:
    struct DiagnosticReport {
        std::vector<std::string> performance_issues;
        std::vector<std::string> optimization_suggestions;
        std::map<std::string, double> key_metrics;
    };
    
    DiagnosticReport AnalyzePerformance() {
        DiagnosticReport report;
        
        // æ£€æŸ¥å†…å­˜ä½¿ç”¨
        auto memory_usage = GetTotalMemoryUsage();
        if (memory_usage > kMemoryWarningThreshold) {
            report.performance_issues.push_back("High memory usage detected");
            report.optimization_suggestions.push_back("Consider reducing open tabs");
        }
        
        // æ£€æŸ¥æ¸²æŸ“æ€§èƒ½
        auto average_fps = GetAverageFrameRate();
        if (average_fps < kMinimumFPS) {
            report.performance_issues.push_back("Low frame rate detected");
            report.optimization_suggestions.push_back("Enable GPU acceleration");
        }
        
        // æ£€æŸ¥ç½‘ç»œæ€§èƒ½
        auto network_latency = GetNetworkLatency();
        if (network_latency > kLatencyThreshold) {
            report.performance_issues.push_back("High network latency");
            report.optimization_suggestions.push_back("Enable HTTP/2 or check proxy settings");
        }
        
        return report;
    }
};
```

---

## ğŸš€ æ€»ç»“ä¸æœ€ä½³å®è·µ

### å¤šè¿›ç¨‹æ¶æ„ä¼˜åŠ¿æ€»ç»“

| ä¼˜åŠ¿ç»´åº¦ | å…·ä½“æ”¶ç›Š | é‡åŒ–æŒ‡æ ‡ | å®ç°æˆæœ¬ |
|---------|---------|---------|----------|
| **ç¨³å®šæ€§** | å•é¡µé¢å´©æºƒä¸å½±å“æ•´ä½“ | ğŸ”„ å´©æºƒæ¢å¤ç‡ 99%+ | ğŸŸ¢ ä½ |
| **å®‰å…¨æ€§** | è¿›ç¨‹é—´æ²™ç®±éš”ç¦» | ğŸ›¡ï¸ å®‰å…¨æ¼æ´å‡å°‘ 80% | ğŸŸ¡ ä¸­ç­‰ |
| **æ€§èƒ½** | å¹¶è¡Œå¤„ç†æå‡å“åº”é€Ÿåº¦ | âš¡ å“åº”æ—¶é—´å‡å°‘ 40% | ğŸ”´ é«˜ |
| **å¯ç»´æŠ¤æ€§** | æ¨¡å—åŒ–æ¶æ„ä¾¿äºå¼€å‘ | ğŸ”§ å¼€å‘æ•ˆç‡æå‡ 30% | ğŸŸ¡ ä¸­ç­‰ |

### å…³é”®è®¾è®¡åŸåˆ™

1. **è¿›ç¨‹èŒè´£å•ä¸€åŒ–** - æ¯ä¸ªè¿›ç¨‹ä¸“æ³¨ç‰¹å®šåŠŸèƒ½
2. **æœ€å°æƒé™åŸåˆ™** - è¿›ç¨‹ä»…è·å¾—å¿…è¦çš„ç³»ç»Ÿæƒé™  
3. **æ•…éšœéš”ç¦»** - å•è¿›ç¨‹æ•…éšœä¸å½±å“å…¶ä»–è¿›ç¨‹
4. **èµ„æºç®¡ç†** - æ™ºèƒ½ç®¡ç†å†…å­˜å’Œ CPU èµ„æº
5. **å®‰å…¨ç¬¬ä¸€** - å¤šå±‚æ²™ç®±é˜²æŠ¤æœºåˆ¶

### å¼€å‘å»ºè®®

```javascript
// ğŸ“± Web å¼€å‘æœ€ä½³å®è·µ
// 1. åˆç†ä½¿ç”¨ Web Workers
const worker = new Worker('heavy-computation.js');
worker.postMessage({data: largeDataSet});

// 2. ä¼˜åŒ–æ¸²æŸ“æ€§èƒ½
const element = document.getElementById('animation-target');
element.style.willChange = 'transform'; // æå‡åˆ°åˆæˆå±‚

// 3. å‡å°‘å†…å­˜æ³„æ¼
function cleanup() {
    // ç§»é™¤äº‹ä»¶ç›‘å¬å™¨
    element.removeEventListener('click', handler);
    
    // æ¸…ç†å®šæ—¶å™¨
    clearInterval(timer);
    
    // æ–­å¼€ Observer è¿æ¥
    observer.disconnect();
}

// 4. åˆ©ç”¨æµè§ˆå™¨é¢„åŠ è½½
const link = document.createElement('link');
link.rel = 'preload';
link.href = 'critical-resource.js';
link.as = 'script';
document.head.appendChild(link);
```

ç°ä»£æµè§ˆå™¨çš„å¤šè¿›ç¨‹æ¶æ„æ˜¯ Web æŠ€æœ¯å‘å±•çš„é‡è¦é‡Œç¨‹ç¢‘ã€‚ç†è§£å…¶å·¥ä½œåŸç†ï¼Œä¸ä»…èƒ½å¸®åŠ©æˆ‘ä»¬ç¼–å†™æ›´é«˜æ•ˆçš„ Web åº”ç”¨ï¼Œè¿˜èƒ½åœ¨é‡åˆ°æ€§èƒ½é—®é¢˜æ—¶å¿«é€Ÿå®šä½å’Œè§£å†³ã€‚

éšç€ Web åº”ç”¨å¤æ‚åº¦çš„ä¸æ–­æå‡ï¼Œæµè§ˆå™¨æ¶æ„ä¹Ÿåœ¨æŒç»­æ¼”è¿›ã€‚ä»å¤šè¿›ç¨‹åˆ°æœåŠ¡åŒ–ï¼Œä»å®‰å…¨éš”ç¦»åˆ°æ€§èƒ½ä¼˜åŒ–ï¼Œæ¯ä¸€æ¬¡æŠ€æœ¯é©æ–°éƒ½ä¸ºå¼€å‘è€…æä¾›äº†æ›´å¼ºå¤§çš„å¹³å°èƒ½åŠ›ã€‚

ğŸŒŸ **æŒæ¡æµè§ˆå™¨å¤šè¿›ç¨‹æ¶æ„ï¼Œå°±æ˜¯æŒæ¡äº†ç°ä»£ Web å¼€å‘çš„æ ¸å¿ƒæŠ€æœ¯åŸºç¡€ï¼**
