---
title: "浏览器工作原理"
description: "深入理解浏览器的工作机制，从导航到渲染的完整流程"
pubDate: 2024-01-10
---

# 浏览器工作原理

## 🎯 概览

现代 Web 应用的用户体验很大程度上取决于浏览器的性能表现。

**用户期待什么？**
- ⚡ 内容快速加载
- 🔄 流畅的交互体验  
- 📱 响应式的界面反馈

### 性能瓶颈的两大根源

| 瓶颈类型 | 影响范围 | 优化策略 |
|---------|---------|---------|
| **网络延迟** | 页面加载速度 | 减少请求次数、启用缓存、CDN加速 |
| **单线程执行** | 交互响应性 | 异步处理、任务分片、避免阻塞 |

#### 1. 网络延迟挑战
网络延迟是数据从服务器传输到用户设备所需的时间。每个 HTTP 请求都会产生往返时间(RTT)成本。

**优化目标：**
- 最小化关键资源的加载时间
- 实现渐进式内容展示
- 提供即时的用户反馈

#### 2. 单线程执行限制
浏览器主线程负责处理 JavaScript 执行、DOM 操作和渲染任务。

**关键理解：**
- 主线程被阻塞时，用户界面会失去响应
- 长时间运行的任务会导致页面卡顿
- 合理分配主线程资源是性能优化的核心

---

## 🧭 导航流程

导航是用户访问网页的第一步，决定了首次内容展示的速度。

### DNS 查询：将域名转换为 IP 地址

当用户在地址栏输入 `www.example.com` 时，浏览器需要找到对应的服务器 IP 地址。

#### 🔍 查询流程详解

**第一步：本地缓存检查**
```bash
# 检查顺序
1. 浏览器缓存 → 命中率: ~30%
2. 操作系统缓存 → 命中率: ~15% 
3. 路由器缓存 → 命中率: ~10%
```

**第二步：递归解析器查询**
- 通常由 ISP 提供(如 8.8.8.8, 1.1.1.1)
- 负责完成整个查询链路
- 维护大型缓存减少重复查询

**第三步：权威服务器查询**
```
用户设备 → 递归解析器 → 根服务器(.root)
                    ↓
           TLD服务器(.com) → 权威服务器(example.com)
```

#### 📊 DNS 查询类型对比

| 查询类型 | 客户端工作量 | 服务器负担 | 使用场景 |
|---------|-----------|----------|---------|
| **递归查询** | 极低（1次请求） | 高 | 终端用户设备 |
| **迭代查询** | 高（多次请求） | 低 | 服务器间通信 |
| **非递归查询** | 低（1次请求） | 极低 | 缓存命中/权威查询 |

#### ⚡ 性能优化策略

**DNS 预解析**
```html
<!-- 提前解析关键域名 -->
<link rel="dns-prefetch" href="//api.example.com">
<link rel="dns-prefetch" href="//cdn.example.com">
```

**DNS 缓存配置**
```bash
# 设置合理的 TTL 值
TTL: 300s   # 5分钟 - 频繁更新的记录
TTL: 3600s  # 1小时 - 普通网站
TTL: 86400s # 24小时 - 稳定服务
```

---

## 🤝 TCP 三次握手

获取服务器 IP 后，浏览器通过 TCP 协议建立可靠连接。

### 握手过程解析

```
客户端                    服务器
   |                        |
   |-- SYN(seq=x) --------->|  1️⃣ 请求连接
   |                        |
   |<------ SYN-ACK --------|  2️⃣ 确认并请求
   |    (seq=y, ack=x+1)    |
   |                        |
   |-- ACK(ack=y+1) ------->|  3️⃣ 最终确认
   |                        |
   |  🎉 连接建立成功        |
```

### 性能影响分析

**时间成本：**
- 每次连接需要 1.5 个 RTT
- 地理距离影响 RTT（北京到美国 ~200ms）
- 移动网络 RTT 通常更高（50-300ms）

**优化方案：**
```html
<!-- HTTP/2 多路复用 -->
<link rel="preconnect" href="https://api.example.com">

<!-- 连接保活 -->
Connection: keep-alive
Keep-Alive: timeout=60, max=100
```

---

## 🔐 TLS 安全握手

HTTPS 连接需要额外的 TLS 握手确保通信安全。

### 握手步骤

1. **协议协商** - 确定 TLS 版本和密码套件
2. **证书验证** - 验证服务器身份
3. **密钥交换** - 生成会话加密密钥
4. **握手完成** - 开始加密通信

### 🛡️ 安全性 vs 性能

| TLS 版本 | 握手次数 | 安全性 | 性能 | 推荐使用 |
|---------|---------|-------|------|---------|
| TLS 1.2 | 2-RTT | 高 | 中等 | ⚠️ 逐步淘汰 |
| TLS 1.3 | 1-RTT | 极高 | 优秀 | ✅ 强烈推荐 |

### 性能优化技巧

**会话复用**
```nginx
# Nginx 配置示例
ssl_session_cache shared:SSL:10m;
ssl_session_timeout 10m;
ssl_session_tickets on;
```

**OCSP Stapling**
```nginx
# 减少证书验证时间
ssl_stapling on;
ssl_stapling_verify on;
```

---

## 📈 性能监控指标

### 关键时间节点

```javascript
// 使用 Navigation Timing API 监控
const perfData = performance.getEntriesByType('navigation')[0];

const metrics = {
  // DNS 查询时间
  dnsTime: perfData.domainLookupEnd - perfData.domainLookupStart,
  
  // TCP 连接时间  
  tcpTime: perfData.connectEnd - perfData.connectStart,
  
  // TLS 握手时间
  tlsTime: perfData.connectEnd - perfData.secureConnectionStart,
  
  // 总体导航时间
  totalTime: perfData.loadEventEnd - perfData.navigationStart
};
```

### 性能基准参考

| 指标 | 优秀 | 良好 | 需优化 |
|------|------|------|--------|
| DNS 查询 | <20ms | <100ms | >200ms |
| TCP 连接 | <100ms | <300ms | >500ms |
| TLS 握手 | <200ms | <500ms | >1s |

---

## 🎯 优化实战总结

### 立即可行的优化措施

1. **启用 DNS 预解析**
   ```html
   <link rel="dns-prefetch" href="//critical-domain.com">
   ```

2. **升级到 TLS 1.3**
   ```bash
   # 检查当前 TLS 版本
   openssl s_client -connect example.com:443 -tls1_3
   ```

3. **配置连接复用**
   ```javascript
   // 使用 fetch API 时保持连接
   fetch('/api/data', { keepalive: true })
   ```

### 下一步学习方向

- 🔄 **渲染流程** - 了解 DOM 构建和样式计算
- ⚡ **JavaScript 引擎** - V8 执行机制深度解析  
- 🎨 **渲染优化** - 重排重绘与合成层优化

## 响应

一旦我们建立了和 web 服务器的连接，浏览器就会代表用户发送一个初始的 HTTP GET 请求，对于网站来说，这个请求通常是一个 HTML 文件。一旦服务器收到请求，它将使用相关的响应头和 HTML 的内容进行回复。
初始请求的响应包含所接收数据的第一个字节。首字节时间（TTFB）是用户通过点击链接进行请求与收到第一个 HTML 数据包之间的时间。第一个内容分块通常是 14KB 的数据。

### 拥塞控制 / TCP 慢启动

在传输过程中，TCP 包被分割成段。由于 TCP 保证了数据包的顺序，因此服务器在发送一定数量的分段后，必须从客户端接收一个 ACK 包的确认。

如果服务器在发送每个分段之后都等待 ACK，那么客户端将频繁地发送 ACK，并且可能会增加传输时间，即使在网络负载较低的情况下也是如此。

另一方面，一次发送过多的分段会导致在繁忙的网络中客户端无法接收分段并且长时间地只会持续发送 ACK，服务器必须不断重新发送分段的问题。

为了平衡传输分段的数量，TCP 慢启动算法用于逐渐增加传输数据量，直到确定最大网络带宽，并在网络负载较高时减少传输数据量。

传输段的数量由拥塞窗口（CWND）的值控制，该值可初始化为 1、2、4 或 10 MSS（以太网协议中的 MSS 为 1500 字节）。该值是发送的字节数，客户端收到后必须发送 ACK。

如果收到 ACK，那么 CWND 值将加倍，这样服务器下次就能发送更多的数据分段。相反，如果没有收到 ACK，那么 CWND 值将减半。因此，这种机制在发送过多分段和过少分段之间取得了平衡。

### 14KB 的依据

"14KB"依据来源于早期 Web 性能优化领域的经验规则，具体与 TCP 网络传输的初始拥塞窗口（Initial Congestion Window，简称 Initial CWND）和浏览器行为有关。

1. 在 TCP 协议中，数据传输采用"慢启动"（Slow Start）机制。发送方（如服务器）一开始不会一次性发送大量数据，而是从一个较小的初始拥塞窗口（Initial CWND）开始，逐步增加发送的数据量。在早期的互联网标准中（如 RFC 2581，1999 年），TCP 的初始拥塞窗口被建议设置为 2-4 个 MSS（Maximum Segment Size，最大分段大小）。MSS 通常由网络的最大传输单元（MTU）决定，默认情况下是以太网的 MTU 为 1500 字节，去掉 TCP 和 IP 头部（约 40 字节），MSS 约为 1460 字节。因此，初始拥塞窗口大约是 2 × 1460 = 2920 字节（约 3KB）到 4 × 1460 = 5840 字节（约 6KB）。

2. 在实际的 HTTP 请求中，浏览器通常在一个 TCP 连接的第一个往返（RTT，Round-Trip Time）中接收服务器返回的数据。这个数据量受限于初始拥塞窗口。为了提高性能，Web 优化专家（如 Steve Souders）在 2000 年代提出，服务器应该在第一个数据包中返回足够多的内容，让浏览器可以开始解析和渲染页面。当时的经验值逐渐演变为 14KB，因为：

   - 随着网络优化，初始拥塞窗口逐渐被调大到 10 个 MSS（约 14KB），特别是在 Google 的推动下（详见后文）。
   - 14KB 被认为是一个合理的折中值，既能容纳关键的 HTML 和 CSS，又不会超过大多数网络环境的初始传输能力。

3. 浏览器的确可以在接收到第一个数据分块后开始解析 HTML（增量解析），而无需等待整个响应完成。14KB 的经验规则源于这样一个假设：如果前 14KB 包含关键渲染路径所需的内容（HTML 结构和关键 CSS），浏览器就能尽早开始构建 DOM 和 CSSOM，从而减少"首次渲染时间"（First Contentful Paint, FCP）。

### 具体计算依据

1. 初始拥塞窗口的演变：
   在 2010 年，Google 提出了将初始拥塞窗口从 4 MSS 增加到 10 MSS 的建议（RFC 6928，2013 年正式标准化）。这意味着初始窗口从 6KB 左右增加到 10 × 1460 = 14,600 字节，约 14KB。
   14KB 因此成为 Web 性能优化中的一个关键数字，因为它代表了服务器在第一个 RTT 中可以无延迟发送的最大数据量。
2. HTTP 头部开销：
   HTTP 响应包括响应头（通常几百字节）和响应体。假设头部占用 400 字节，剩余约 14KB 可用于 HTML、CSS 等内容。
3. 浏览器缓冲区：
   浏览器通常会缓冲一定量的数据后再开始解析。14KB 接近早期浏览器的缓冲区大小，确保解析器有足够的数据开始工作。

浏览器的渲染过程需要 HTML（构建 DOM）、CSS（构建 CSSOM）和可能的 JavaScript。如果这些关键资源能在第一个数据包（14KB）内交付，浏览器可以更快地完成首次渲染。
如果 HTML 超过 14KB，浏览器可能需要额外的 RTT 来接收剩余数据，延迟渲染。

浏览器接收到 HTML 后的渲染解析过程是一个复杂且高度优化的流程，它将原始的 HTML 文本转化为用户可见的页面。这个过程涉及多个步骤，包括解析 HTML 构建 DOM、解析 CSS 构建 CSSOM、结合两者生成渲染树（Render Tree），以及后续的布局和绘制等阶段。以下是对这一过程的详细说明，按步骤展开：

## **HTML 解析与 DOM 树构建 （增量构建）**

HTML 解析的核心是将 HTML 文本转换为**文档对象模型（DOM，Document Object Model）**，这是浏览器对页面结构的内存表示。

1. **令牌化（Tokenization）**：

   - HTML 被分解为一个个"令牌"（Token），如开始标签（`<div>`）、结束标签（`</div>`）、文本内容等。
   - 浏览器使用状态机（State Machine）处理字符流，识别标签、属性和内容。
   - 示例：

     ```html
     <div class="container">Hello</div>
     ```

     被分解为：

     - 开始标签：`<div>`（属性：`class="container"`）
     - 文本：`Hello`
     - 结束标签：`</div>`

2. **DOM 树构建（Tree Construction）**：

   - 令牌被组织成树状结构，形成 DOM 树。
   - 规则：
     - 开始标签创建一个节点，放入树中。
     - 嵌套标签成为子节点。
     - 结束标签关闭当前节点。
   - 示例结果（简化的 DOM 树）：

   ```tsx
    Document
      └── div (class="container")
            └── Text: "Hello"
   ```

   - **容错性**：HTML 解析器对语法错误有很强的容错能力。例如，缺少闭合标签时，浏览器会尝试自动补全。

3. **遇到外部资源**：
   - **CSS 文件**：如 `<link rel="stylesheet" href="styles.css">`，浏览器发起并行请求下载 CSS，但不会阻塞 HTML 解析。
   - **JavaScript 文件**：如 `<script src="script.js">`，默认会暂停 HTML 解析，直到脚本下载并执行完成（除非使用 `async` 或 `defer` 属性）。
   - **图片**：如 `<img src="image.jpg">`，异步加载，不阻塞解析。

**关键点：**

- **预加载扫描（Preload Scanner）**：现代浏览器（如 Chrome）会运行一个额外的扫描器，提前发现外部资源并发起请求，优化加载速度。
- **增量解析**：每接收到一部分 HTML，解析器就更新 DOM 树，无需等待全部数据。

## CSS 解析与 CSSOM 构建

与此同时，如果 HTML 中引入了 CSS（如 `<link>` 或 `<style>`），浏览器会解析这些样式，构建**CSS 对象模型（CSSOM，CSS Object Model）**。

1. **CSS 下载**：
   - 浏览器根据 `<link>` 或内联 `<style>` 获取 CSS 内容。
2. **令牌化与解析**：

   - CSS 文本被分解为规则块，如选择器（`div`）、属性（`color: blue`）等。
   - 示例：

     ```css
     div.container {
       color: blue;
       font-size: 16px;
     }
     ```

     被解析为：

     - 选择器：`div.container`
     - 属性：`color: blue`, `font-size: 16px`

3. **CSSOM 树构建**：

   - CSS 规则被组织成树状结构，与 DOM 树对应。
   - CSSOM 表示每个 DOM 节点的样式信息。
   - 示例结果（简化的 CSSOM）：

     ```tsx
     CSSStyleSheet
       └── Rule
           ├── Selector: "div.container"
           └── Declarations: { color: blue, font-size: 16px }
     ```

**关键点：**

- **阻塞性**：CSSOM 的构建会阻塞渲染，因为浏览器需要知道元素的样式才能绘制页面，所以在 CSSOM 完成之前无法渲染内容。
- **层叠与优先级**：浏览器计算 CSS 规则的优先级（基于选择器特异性、顺序和 `!important`），最终确定每个节点的样式。

## 渲染树（Render Tree）生成

DOM 和 CSSOM 构建完成后，浏览器将两者结合，生成**渲染树**，这是实际用于渲染的结构。

1. **合并 DOM 和 CSSOM**：
   - 遍历 DOM 树，为每个节点应用匹配的 CSSOM 规则。
   - 只包含**可见元素**（如 `display: none` 的节点被排除）。
2. **渲染树结构**：

   - 每个节点包含几何信息（如位置、大小）和绘制信息（如颜色、边框）。
   - 示例：

     ```tsx
     RenderObject (div.container)
       ├── Style: { color: blue, font-size: 16px }
       └── Child: RenderText ("Hello")
     ```

**关键点：**

- **优化**：不可见元素（如 `<head>`、`<meta>`）不进入渲染树，减少计算开销。
- **动态性**：如果 JavaScript 修改了 DOM 或 CSSOM，渲染树会随之更新。

## **布局（Layout / Reflow）**

渲染树生成后，浏览器计算每个元素在页面中的具体位置和大小。

1. **坐标计算**：
   - 从根节点（通常是 `<html>`）开始，递归计算每个节点的宽度、高度、边距、位置等。
   - 使用盒模型（Box Model）确定内容区、内边距、边框和外边距。
2. **流式布局**：
   - 根据 CSS 属性（如 `float`、`position`）安排元素。
   - 示例：`div.container` 的位置基于其父元素和兄弟元素。

布局性能受 DOM 影响——节点数越多，布局就需要更长的时间。如果在滚动或其他动画过程中需要布局，布局可能会成为一个瓶颈，从而导致卡顿。20ms 的延迟在加载或者方向改变时或许还可以接受，但在动画或滚动时就会变得卡顿。任何渲染树改变的时候，像添加节点、改变内容或者在一个节点更新盒模型样式的时候就会开始布局。

为了减小布局事件的频率和时长，我们应该批量更新或者避免改动盒模型属性。

**关键点：**

- **视口依赖**：布局结果依赖浏览器窗口大小（Viewport）。
- **重排（Reflow）**：窗口缩放或 DOM 修改可能触发重新布局，消耗性能。

## 绘制（Painting）

布局完成后，浏览器将渲染树转换为屏幕上的像素。

1. **绘制指令**：
   - 将渲染树的每个节点转换为绘制操作（如填充矩形、绘制文本）。
   - 示例：`div.container` 被绘制为蓝色文字 "Hello"。
2. **分层**：
   - 浏览器将页面分成多个层（如背景、前景），便于后续优化。
3. **光栅化（Rasterization）**：
   - 将绘制指令转为位图，由 GPU 或 CPU 执行。

**关键点：**

- **性能优化**：GPU 加速（如硬件加速的 CSS 动画）提高绘制效率。
- **重绘（Repaint）**：样式变化（如颜色改变）可能触发部分重绘。

---

## 合成（Compositing）

现代浏览器（如 Chrome）使用合成技术，将分层内容组合成最终画面。

1. **层管理**：
   - 独立的层（如固定定位元素）单独处理。
2. **合成**：
   - GPU 将所有层合并，生成最终屏幕显示。

**关键点：**

- **高效更新**：仅更新变化的层，避免全局重绘。
- **硬件加速**：CSS 属性如 `transform` 或 `opacity` 会触发合成优化。

## **关键特性与优化**

- **增量渲染**：浏览器边解析边渲染，减少白屏时间。
- **并发解析与预加载**: 在解析 HTML 时提前发现资源（如图片、脚本），并发请求以缩短加载时间。
- **滚动优化**：合成线程独立处理滚动事件，无需主线程参与，滚动更流畅。
- **阻塞点**：
  - CSS 阻塞渲染（需等待 CSSOM）。
  - 同步 JavaScript 阻塞解析（需执行完成）。
- **性能优化建议**：
  - 减少关键资源大小（如前 14KB 包含关键 HTML/CSS）。
  - 使用 `async`/`defer` 加载脚本。
  - 内联关键 CSS，异步加载非关键资源。
  - 合并 DOM 和样式操作
  - 通过 transform 和 opacity 跳过布局与绘制,或者添加 `will-change` 或伪 3D 属性触发硬件加速。
  - 避免强制同步布局，分离读写操作。

## 交互

一旦主线程绘制页面完成，你会认为我们已经"准备好了"，但事实并非如此。如果加载包括正确延迟加载的 JavaScript，并且仅在 onload 事件触发后执行，那么主线程可能会忙于执行脚本，无法用于滚动、触摸和其他交互操作。

可交互时间（TTI）是测量从第一个请求导致 DNS 查询和 SSL 连接到页面可交互时所用的时间——可交互是在首次内容绘制之后页面在 50ms 内响应用户的交互。如果主线程正在解析、编译和执行 JavaScript，则无法及时（小于 50ms）响应用户交互。

在我们的示例中，可能图像加载很快，但 anotherscript.js 文件的大小可能是 2MB，而且用户的网络连接很慢。在这种情况下，用户可以非常快地看到页面，但是在下载、解析和执行脚本之前，就无法滚动。这不是一个好的用户体验。避免占用主线程，如下面的网页测试示例所示：
